<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Linear Burn Shader Demo</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://rawcdn.githack.com/locomotivemtl/locomotive-scroll/3e3bf62d1ea55586d69403dc6325b4f34130f3a8/dist/locomotive-scroll.min.css"
    />
    <!-- p5.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div class="custom-cursor" id="cursor"></div>
    <div class="nav">
      <nav class="textmenu">
        <a href="./index.html">Home</a>
        <a href="./contact.html">Contact</a>
        <a href="./profile.html">Profile</a>
        <a href="./project.html">Projects</a>
        <a href="./skills.html">Skills</a>
        <span></span>
      </nav>
    </div>
    <div class="container">
      <h1>Hello World!</h1>
      <br>
      <h4>FE 개발자 김이레 입니다!</h4>
      <div class="buttons">
        <button class="button"  onclick="location.href='./intro.html'">
          <span>더 알아보러가기</span>
        </button>
      </div>
    </div>
    <!-- Vertex Shader -->
    <script id="vertShader" type="x-shader/x-vertex">
      attribute vec3 aPosition;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
      }
    </script>

    <!-- Fragment Shader -->
    <script id="fragShader" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform float uTime;
      uniform float uSpeedColor;
      uniform vec2 uResolution;

      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform vec3 uColor3;
      uniform vec3 uColor4;
      uniform vec3 uColor5;

      const int AMOUNT = 2;
      const float scale = 2.0;

      // Blend functions
      vec3 blendLinearBurn(vec3 base, vec3 blend) {
        return max(base + blend - vec3(1.0), vec3(0.0));
      }

      vec3 blendOverlay(vec3 base, vec3 blend) {
        return vec3(
          base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),
          base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),
          base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))
        );
      }

      float rand(vec2 co) {
        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
      }

      float createLen() {
        float time = 10.0 + uTime / 1.0;
        vec2 coord = scale * (gl_FragCoord.xy - uResolution.xy) / min(uResolution.y, uResolution.x);
        float len;
        for(int i = 0; i < AMOUNT; i++) {
          len = length(vec2(coord.x, coord.y));
          coord.x = coord.x + cos(coord.y - sin(len)) - cos(time / 9.1);
          coord.y = coord.y + sin(coord.y + cos(len)) + sin(time / 12.0);
        }
        return len;
      }

      float createLen2(float x, float y, float speed, float offset) {
        float time = offset + uTime / speed;
        vec2 coord = scale * (gl_FragCoord.xy - uResolution.xy) / min(uResolution.y, uResolution.x);
        float len;
        for(int i = 0; i < AMOUNT; i++) {
          len = length(vec2(coord.x, coord.y));
          coord.x = coord.x + sin(coord.y + cos(len) * cos(len)) + sin(time / x);
          coord.y = coord.y - cos(coord.y + sin(len) * sin(len)) + cos(time / y);
        }
        return len;
      }

      float createLen3(float x, float y, float speed, float offset) {
        float time = offset + uTime / speed;
        vec2 coord = scale * (gl_FragCoord.xy - uResolution.xy) / min(uResolution.y, uResolution.x);
        float len;
        for(int i = 0; i < AMOUNT; i++) {
          len = length(vec2(coord.x, coord.y));
          coord.y = coord.y + sin(coord.y + cos(len)) + sin(time / y);
        }
        return len;
      }

      float createLen4(float x, float y, float speed, float offset) {
        float time = offset + uTime / speed;
        vec2 coord = scale * (gl_FragCoord.xy - uResolution.xy) / min(uResolution.y, uResolution.x);
        float len;
        for(int i = 0; i < AMOUNT; i++) {
          len = length(vec2(coord.x, coord.y));
          coord.x = coord.x - cos(coord.y + sin(len)) + cos(time / x);
        }
        return len;
      }

      // rgb2hsv & hsv2rgb from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl
      vec3 rgb2hsv(vec3 c) {
        vec4 K = vec4(0., -1./3., 2./3., -1.);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
        float d = q.x - min(q.w, q.y);
        float e = 1e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.*d + e)), d / (q.x + e), q.x);
      }

      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1., 2./3., 1./3., 3.);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
      }

      void main() {
        float len = createLen();
        float len2 = createLen2(10.0, 10.0, 8.0, 20.0);
        float len3 = createLen3(2.0, 2.0, 10.0, 30.0);
        float len4 = createLen4(5.0, 20.0, 5.0, 40.0);

        vec3 blue = uColor1 + cos(len) * 0.25 + 0.25;
        vec3 turquoise = uColor2 + cos(len2) * 0.5 + 0.75;
        vec3 pink = uColor3 + cos(len3) * 0.5 + 0.75;
        vec3 peach = uColor4 + cos(len4) * 0.75 + 0.95;

        float pinkValue = min(1.0, max(0.0, 1.2 - (pink[0] / 1.2)));
        float peachValue = min(1.0, max(0.0, 1.5 - (peach[0] / 1.2)));
        float turquoiseValue = min(1.0, max(0.0, 1.5 - (turquoise[2] / 1.1)));

        vec3 blend = blue;
        blend = mix(blend, turquoise, turquoiseValue);
        blend = mix(blend, peach, peachValue);
        blend = mix(blend, pink, pinkValue);

        vec3 lightercolor = blendLinearBurn(blend, peach);
        blend = mix(blend, lightercolor, max(1.0 - lightercolor[0], 0.0));

        blend = blendOverlay(blend, vec3(0.0, 0.0, 0.0));
        blend = blendLinearBurn(blend, vec3(1.0, 0.7, 0.1));

        vec3 color = blend;

        float r = color[0];
        float g = color[1];
        float b = color[2];

        vec3 hsb = rgb2hsv(vec3(r, g, b));
        hsb[1] -= rand(scale * (gl_FragCoord.xy - uResolution.xy) / min(uResolution.y, uResolution.x)) * 0.4;
        vec3 rgb = hsv2rgb(hsb);

        gl_FragColor = vec4(rgb, 1.0);
      }
    </script>

    <script>
      // p5.js sketch code inside script tag
      const colors = ["#225ee1", "#83dcb7", "#ac53cf", "#e7a39c"];
      const backgroundColor = "#31AFD4";
      let s;
      let canvasWidth;
      let canvasHeight;

      function setup() {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        createCanvas(canvasWidth, canvasHeight, WEBGL);
        noiseSeed(20);
        rectMode(CENTER);
        noStroke();

        let vert = document.getElementById("vertShader").textContent;
        let frag = document.getElementById("fragShader").textContent;
        s = createShader(vert, frag);
      }

      function draw() {
        background(backgroundColor);
        shader(s);

        s.setUniform("uResolution", [canvasWidth, canvasHeight]);
        s.setUniform("uTime", millis() / 100);
        s.setUniform("uSpeedColor", 20.0);

        s.setUniform("uColor1", hex2rgb(colors[0]));
        s.setUniform("uColor2", hex2rgb(colors[1]));
        s.setUniform("uColor3", hex2rgb(colors[2]));
        s.setUniform("uColor4", hex2rgb(colors[3]));
        s.setUniform("uColor5", [0, 0, 0]); // 임시값

        rect(0, 0, canvasWidth, canvasHeight);
      }

      function hex2rgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r / 255, g / 255, b / 255];
      }

      function windowResized() {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        resizeCanvas(canvasWidth, canvasHeight);
      }
      // 커스텀 커서 코드
      const cursor = document.getElementById("cursor");
      let mouseX = 0;
      let mouseY = 0;
      let cursorX = 0;
      let cursorY = 0;

      // 마우스 움직임 추적
      document.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      // 부드러운 커서 움직임을 위한 애니메이션
      function animateCursor() {
        const speed = 0.2;
        cursorX += (mouseX - cursorX) * speed;
        cursorY += (mouseY - cursorY) * speed;

        cursor.style.left = cursorX + "px";
        cursor.style.top = cursorY + "px";

        requestAnimationFrame(animateCursor);
      }

      // 커서 애니메이션 시작
      animateCursor();

      // 링크 호버 효과
      const links = document.querySelectorAll(".textmenu a");
      links.forEach((link) => {
        link.addEventListener("mouseenter", () => {
          cursor.style.transform = "translate(-50%, -50%) scale(1.5)";
          cursor.style.background = "rgba(172, 83, 207, 0.8)";
          cursor.style.borderColor = "rgba(172, 83, 207, 0.5)";
        });

        link.addEventListener("mouseleave", () => {
          cursor.style.transform = "translate(-50%, -50%) scale(1)";
          cursor.style.background = "rgba(255, 255, 255, 0.8)";
          cursor.style.borderColor = "rgba(255, 255, 255, 0.5)";
        });
      });
    </script>
  </body>
</html>
